# 第9　インデックス使用上の注意

他のRDBMSと同様、TiDBはインデックスによってデータ読み取りパフォーマンスを担保します。TiDBはしばしばスタンドアロン型RDBMSでは扱いが難しい膨大なデータをロードすることがあるため、インデックスに適合する設計が重要となります。

### 1. TiDBのインデックス
インデックスもデータであり、ストレージ容量を消費します。テーブルのデータと同様、TiDBのテーブルのインデックスもストレージエンジンではkvとして保存され、インデックス1行が1つのキー/値ペアとなります。例えば、10インデックスあるテーブルにデータを1行追加すると、1つのデータと10のインデックス追加で、合計11のキー/値ペアが書き込まれます。

TiDBは、主キーインデックス、一意のインデックスのほか、セカンダリインデックスもサポートしています。これらのインデックスを構成するのは単一列でも複数列（複合インデックス）でもかまいません。

TiDB v5.0では転置/降順インデックス、フルテキストインデックス、パーティションテーブルのグローバルインデックスをサポートしていません。

TiDBのクエリでの述語が **=、>、<、>=、<=、like‘...%’、not like‘...%’、..in、’not in、<>、!=、is null、<=>、is not null、between…and…** である場合、インデックスを使用できます。使用するかどうかはオプティマイザが決定します。

TiDBのクエリの述語が、前方一致の正規表現の場合（例: **like‘%...’、like‘%...%’、notlike‘%..、.’notlike‘%...%’** ）である場合、インデックスは使用できません。

### 2. 複合インデックス設計
TiDBの複合インデックス型（`key indeXkeyname (a,b,c)`など）については、他のデータベースと同様、複合インデックス設計の基本原則は、使用頻度の高いフィールドを可能な限り前段に配置することです。TiDB v5.0以降のバージョン使用時には、複合インデックスの前列の範囲クエリによって後続インデックス列の使用が中断されることがあることに注意が必要です。この特性は次の例で理解できます。次のようなクエリ: `select a,b,c from tablename where a<predicate>’<value1>’ and b<predicate>’<value2>’ and c<predicate>’<value3>’;`

a条件の述語（句のpredicate）が=かinの場合、bのクエリ条件で結合インデックス(a,b,c)を使用できます。例: `select a,b,c from tablename where a=1 and b<5 and c=’abc’;`

同様に、a条件とb条件の述語が=かinの場合、cのクエリで結合インデックス(a,b,c)を使用できます。例: `select a,b,c from tablename where a in (1,2,3) and b=5 and c=’abc’;`

a条件の述語が=でもinでもない場合、bのクエリで結合インデックス(a,b,c)を使用できません。このとき、b条件はa条件のフィルタリング後データで、インデックスなしのデータスキャンを実行します。例: `select a,b,c from tablename where a>1 and b<5 and c=’abc’;`

これは、TiDBでは、複合インデックスの前段に配置された列が範囲クエリに使用されると、後続列のクエリが前列のフィルタリング後データ範囲でインデックスなしでスキャンされるためです。以上のことから、TiDBでの複合インデックス設計時には、可能な限り使用頻度が高く、ポイントクエリによく使用される列を前段に、範囲クエリによく使用される列を後段に配置する必要があります。

また、`select c, count(*) from tabname where a=1 and b=2 group by c order by c;` などの型のクエリは、インデックス(a,b,c)で使用でき、同様に上記の原則に従います。
