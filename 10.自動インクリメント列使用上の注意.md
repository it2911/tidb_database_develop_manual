# 第10　自動インクリメント列使用上の注意

### 1. 原理
TiDBの自動インクリメントID（`auto_increment`）は、自動インクリメントかつ固有であることのみを担保するものであり、連続分布であることを担保しません。TiDBは現在バッチ設定方式をとっているため、複数のTiDBに同時にデータを追加すると、設定された自動インクリメントIDは不連続となります。複数のスレッドが同時にさまざまなtidb-serverにデータを追加すると、その後追加するデータの自動インクリメントIDが小さくなることがあります。また、TiDBは数値型の列に`auto_increment`を指定することを許容し、1つのテーブルはプロパティが`auto_increment`である列1つのみを許容します。

###2. ベストプラクティス
自動インクリメントIDを設定する目的は通常、これをテーブル内データのユニーク制約とすることです。このため、主キーか一意のインデックスに設定された型の列プロパティにはNOT NULLが必要となります。

自動インクリメントID列の型は整数型である必要があります。整数型では、bigintの使用を推奨します。これは、スタンドアロン型データベースでも数少ないint型の自動インクリメントIDが使用し尽くされていても、TiDBがスタンドアロンデータよりずっと大きいデータ量の処理に使用されるためです。また、TiDBはマルチスレッドにより自動インクリメントIDを設定しているため、int型では条件を満たしません。また、自動インクリメントIDは通常、負の値を格納することなく、列にunsignedプロパティを追加することで、ID格納容量を2倍にすることができます。intの記号なし範囲は0から4294967295まで、bigintの記号なし範囲は0から18446744073709551615までです。

以上のことから、自動インクリメントID設計のベストプラクティスは次のようになります。

`'auto_inc_id' bigint unsigned not null unique key auto_increment comment '自動インクリメントID'`

### 3. 人為的な値割り当ての結果と対応策
クラスタ内に複数のtidb-serverがある場合、自動インクリメント列に人為的に値を書き込むと、自動インクリメント値で異常が発生し、「Duplicate entry」エラーが表示されることがあります。

次のような自動インクリメントIDのあるテーブルがあるとします。`CREATE table t(id int unique key auto_increment, c int);`

TiDBによる自動インクリメントID実現の原理は、tidb-serverインスタンスがID値セグメントを割り当てのためにキャッシュし（現時点では30000IDをキャッシュ）、そのセグメントを使用し終えると次のセグメントを取得するというものです。

クラスタに2つのtidb-serverインスタンスA、B（Aは[1,30000]の自動インクリメントIDを、Bは[30001,60000]の自動インクリメントIDをキャッシュ）があり、次のような操作を実行するものとします。

クライアントサイドがBにIDを1に設定する句`INSERT INTO t values(1, 1)`を追加する。

クライアントサイドがAにInsert句`INSERT INTO t(c)(1)`を送信する。この句にはIDを指定する値がないため、Aが設定する。現時点ではAは[1, 30000]セグメントのIDをキャッシュするため、1を自動インクリメントIDとする値が設定され、ローカルカウンタに1を追加する。このとき、データベースにはIDが1のデータが存在しており、最終的にDuplicated Entryエラーが返される。

この問題に対しては、テーブルの`auto_increment`プロパティ値を大きくするだけで、全てのtidb-serverに自動インクリメントIDセグメントが割り当てられます。

1. テーブルの自動インクリメント値の最大値を確認する。`SHOW CREATE TABLE t;`
2. テーブルの自動インクリメント値最大値をより大きい値に変更する。`ALTER TABLE t AUTO_INCREMENT=120000;`