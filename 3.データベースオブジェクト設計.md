# 第3　データベースオブジェクト設計

### 1. テーブル設計
1. TiDBの1つのテーブルのROWIDは主キーのバイト順にソートされており（整数型の主キーについては、特定のコードを使用し、バイト順がサイズ順と同じになるようにします）、CREATE TABLE句に主キーが明示的に作成されていなくても、TiDBがそのテーブルに1つの暗黙の主キーを設定します。
2. TiDBテーブル設計プロセス実行時には、次のいくつかの点に注意する必要があります。
    - プライマリー/セカンダリークラスタのレプリケーション、および、増分バックアップの冪等性を確保するため、テーブルには主キーや一意のインデックスがあり、一意のインデックスの全フィールドが非nullである必要があります（複数のnull値の重複レコードを避けるため）。
    - パフォーマンス上の理由から、極端に広いテーブルは可能な限り作成せず、テーブルフィールド数は60を超えないようにします。1つの行のデータ総量が64Kを超えることは推奨しません。データ長が大きすぎる場合、フィールドを別のテーブルに分解するを推奨します。
    - 複雑なデータ型の使用は推奨しません。
    - joinが必要なフィールドについては、データ型が確実に同じであるようにし、暗黙の変換を避けます。
3. TiDB文字セットはデフォルトではUTF-8です。また、現在はUTF-8のみをサポートしています。
    - TiDBではUTF-8のスーパーセットであるutf8mb4コードを使用しています。接続元がUTF-8を利用している場合、互換性があるため対応は必要ありません。
    - TiDBのutf8mb4のデフォルトソート規則はutf8mb4_binです（大小文字を区別します）。
    - TiDB v4.0以降は、utf8mb4_general_ciをサポートしています（大小文字を区別しません）。

### 2. フィールド設計
1. 整数型
    - TiDBは、INTEGER/INT、TINYINT、SMALLIN、TMEDIUMINT、BIGINTを含むMySQLの全ての整数型をサポートしています。
    - INT：全ての整数型のフィールドについて、INTかBIGINTのみを使用することを推奨します。
    - BIGINT：定義上、長さを指定することは推奨しません。
    - INT(10)UNSIGNEDを使用してIPv4形式のIPアドレスを格納することを推奨します。
    - TINYINT(1)、TINYINT(4)は1バイトを格納しており、括弧内の数字によって変わることはありません。例えば、TINYINT(4)に22格納している場合、0022と表示され、最大幅は4であり、これに到達していないときは0で補われます。

2. 浮動小数点数型
    - TiDBは、FLOAT、DOUBLE、DECIMAL、NUMERICなどを含むMySQLの全ての浮動小数点数型をサポートしています。
    - DECIMAL(M,D)：DECIMAL型の使用を推奨します。floatとdoubleが格納しているときは、精度低下の問題が生じ、値の比較時に不正確な結果が得られる可能性があります。DECIMALはVARCHAR、CHAR型との比較時にDOUBLE型に変換して比較し、ここでも精度低下の問題が生じます。比較時にはCASTなどの表示型を使用して変換し、精度低下の問題を回避することを推奨します。

3. 日付時刻型
    - TiDBは、DATE、DATETIME、TIMESTAMP、TIME、YEARを含むMySQLの全ての日付時刻型をサポートしています。
    - DATE：日単位の正確さのみが求められるフィールドには全て、TIMESTAMPやDATETIME型ではなくDATE型を使用します。
    - DATETIME：時刻（時、分、秒）単位の正確さが求められるフィールドには全て、TIMESTAMP型でなくDATETIMEを使用します。
    - 時刻フィールドには日付時刻型を使用し、文字列型を使用して格納しないでください。日付関数により日付フィールドを操作できず、文字列関数を使用して複雑な操作を行うことが必要になります。

4. 日付と時刻型処理時には次の点に注意してください。
    - 日付部分は月-日-年や日-月-年ではなく、年-月-日の順（例：98-09-04）である必要があります。
    - 日付の値で年の箇所において、西暦の上2桁を省略して2桁の数字として入力した場合、TiDBは次の規則に従って解釈します。
        - 70-99の場合、1970-1999に変換
        - 00-69の場合、2000-2069に変換
    - 実際は日付型もしくは時刻型だがSQLコンテキストにおいて数値型であるとTiDBがと判別した場合、自動的に数値型に変換します。逆の場合も同様です。
    - SQLモードの設定を変更すると、TiDBの動作が変わります。詳細については公式ドキュメントを参照してください。
5. 文字列型
    - TiDBは、CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM、SETを含むMySQLの全ての文字列型をサポートしています。
    - VARCHAR(N)：可変長文字列には全てVARCHAR型を使用します。Nはバイト数ではなく文字数を示します。（例：VARCHAR(256)）Nは実際の幅に応じて選択され、可能な限り小さい数字となります。
    - CHAR：1文字のみのフィールドにはCHAR(1)型を使用します。（例：性別フィールド）
    - TEXT：文字数が20000を超える可能性がある場合のみ、TEXT型に文字型データを格納することを推奨します。これは、TiDBデータベースには全てUTF-8文字セットを使用するためです。TEXT型を使用するフィールドは全て元のテーブルから分割し、元のテーブル主キーと個別に1つのテーブルを構成し、格納することを推奨します。
    - ENUM、SET型の代わりに可能な限りTINYINTを使用することを推奨します。

### 3. フィールドデフォルト値
1. 1つのデータ型記述のDefault valueフィールドに1つの列のデフォルト値を記述しています。このデフォルト値は1つの関数や式ではなく、定数である必要があります。ただし、時刻型については、例外的にNOW、CURRENT_TIMESTAMP、LOCALTIME、LOCALTIMESTAMPなどの関数を、DATETIMEやTIMESTAMPのデフォルト値として使用することができます。
2. BLOB、TEXT、JSONはデフォルト値として設定できません。
3. 1つの列の定義にDEFAULTの設定がない場合、TiDBは次のような規則に従って決定します。
    - その型に値としてnullを使用できる場合、その列は定義時に暗黙のデフォルト値を追加してDEFAULT NULLを設定します。
    - その型に値としてnullを使用できない場合、その列は定義時に暗黙のデフォルト値を追加設定しません。
4. NOT NULLを設定したものの、DEFAULTが明示的に設定されていない列については、INSERT、REPLACEがその列の値を含まない場合、TiDBはその時点のSQL_MODEに基づいて異なる動作をします。
    - このとき、STRICT SQLモードである場合、トランザクションの句がトランザクションの失敗とロールバックを引き起こし、トランザクション以外の句はエラーを報告します。
    - このとき、STRICT SQLモードでない場合、TiDBはその列に列データ型の暗黙のデフォルト値を割り当てます。
5. このとき、暗黙のデフォルト値は次のような規則に従って設定されます。
    - 数値型の場合、デフォルト値は0となる。AUTO_INCREMENTパラメータがある場合、デフォルト値には増分に応じて正しい値が割り当てられる。
    - タイムスタンプ以外の日付時刻型の場合、デフォルト値はその型の「ゼロ値」となる。タイムスタンプ型のデフォルト値はその時点の時刻となる。
    - TIMESTAMPとDATETIME列はその時点の時刻に自動的に更新される。
    - テーブル中の任意のTIMESTAMPやDATETIME列は、デフォルト値や自動更新値をcurrent timestampに指定し、列定義時にDEFAULTCURRENT_TIMESTAMPとON UPDATE CURRENT_TIMESTAMPに指定することで、それらのプロパティを設定できる。DEFAULTも特定の値（例：DEFAULT0やDEFAULT'2000-01-0100:00:00'など）を指定できる。
        ```
        CREATE TABLE t1 (
        ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP);
        ```
    - 列挙型以外の文字列型の場合、デフォルト値はnullとなる。列挙型の場合、デフォルト値は列挙型の最初の値となる。
### 4. インデックス設計
1. カーディナリティの低い列（例：「性別」、「○○○である」）にインデックスを作成するのではなく、差別化の度合いが高い列を選択してインデックスを作成します。
2. 1つのテーブルのインデックス数は5以下とし、冗長インデックスがないようにします。
3. インデックスのフィールド数は5以下を推奨します。
4. 一意のインデックスは3以下のフィールドから構成することを推奨します。
5. 可能な限り頻繁に更新される列にインデックスを作成しないようにします。
6. 可能な限り使用頻度が高く、ポイントクエリによく使用される列を複合インデックスの前段に、範囲クエリによく使用される列を後段に配置します。
7. 左端プレフィックス原則(Leftmost prefix principle)に従い、複合インデックス使用時には左から順にマッチングしていきます。例えば、作成したインデックスidx_c1_c2_c3(c1,c2,c3、)は(c1)、(c1,c2)、(c1,c2,c3)の3つのインデックスに相当し、Where条件に上記3つの状態が含まれるフィールド比較はインデックスに使用できます。ただし、where c1=a and c3=cなどはc1列のインデックスにのみ使用でき、c2=b and c3=cなどはこのインデックスには使用できません。
8. 長い**VARCHAR**フィールドの場合、インデックス作成時にインデックス長を指定できます。全フィールドについてインデックスを作成する必要はなく、実際のテキストの差別化の度合いに応じてインデックス長を決定できます。idx_table_name(name(10))
9. 長期間使用していないインデックスは定期的に削除します。
10. ORDER BY、GROUP BY、DISTINCTのフィールドはインデックスの後に追加し、カバリングインデックスとします。
11. 新しいselect,update,deleteをリリースした場合、explainコマンドなどで実行計画を調査しインデックスの正確性を確認します。
12. **lower(email)** などの関数インデックスをWhere条件に使用した場合、インデックスの利用が選択されない場合列があります。
13. **like** 近似マッチング(%)を使用します。前方一致の近似マッチングではインデックスが使用されないため、1桁目を%としないでください。

### 5. 権限設計 
TiDBはデータベース初期化時に`'root'@'%'`のデフォルトアカウントを作成します。本番環境ではrootユーザーのパスワードを強力にし、ローカルホストか特定のホストからのみの接続を推奨します。ユーザーか業務シーンごとに区分し、実際の状況に基づいて各ユーザーに適宜権限を付与することを推奨します。例：

| 番号 | ユーザー名 | 意味                 | 目的                                         |
|------|------------|----------------------|----------------------------------------------|
| 1    | root       | スーパーユーザー     | グローバル管理、公開禁止                     |
| 2    | dba        | データベース管理者   | データベース DBA                             |
| 3    | app        | アプリケーション開発 | アプリケーション開発                         |
| 4    | tempuser   | 一時ユーザ           | オンライン業務一時統計、読み取り専用ユーザー |
| 5    | other      | その他のユーザー     | 第三者アクセス                               |